package trie_test

import (
	"bytes"
	"crypto/rand"
	"fmt"
	"testing"

	"github.com/lukesolo/merkle-trie"
)

func ExampleLowestNumbers() {
	tree := trie.NewMerkleTrie()
	tree.Add(zero(), nil)
	tree.Add(one(), nil)

	tree.Print()

	// Output:
	// 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 []
	// 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 []
}

func ExampleEmptyMerkleTrieHash() {
	tree := trie.NewMerkleTrie()
	fmt.Printf("%x", tree.Hash())

	// Output:
	// e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
}

func ExampleOneNode() {
	tree := trie.NewMerkleTrie()
	tree.Add([]byte{1}, []byte{2})
	fmt.Printf("%x\n", tree.Hash())

	// Output:
	// dbc1b4c900ffe48d575b5da5c638040125f65db0fe3e24494b76ea986457d986
}

func ExampleSetHighBit() {
	tree := trie.NewMerkleTrie()
	tree.Add(zero(), nil)
	tree.Add(highBit(), nil)

	tree.Print()

	// Output:
	// 0 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 []
	// 1 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 []
}

func ExampleLowestAndHighestNumbers() {
	tree := trie.NewMerkleTrie()
	tree.Add(max(), nil)
	tree.Add(zero(), nil)

	tree.Print()

	// Output:
	// 0 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 []
	// 1 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 []
}

func TestChangeValue(t *testing.T) {
	tree := trie.NewMerkleTrie()

	tree.Add([]byte{0, 0, 0, 0}, []byte{0})
	tree.Add([]byte{255, 255, 0, 128}, []byte{1})
	tree.Add([]byte{255, 255, 0, 0}, []byte{2})
	tree.Add([]byte{127, 255, 0, 1}, []byte{3})
	tree.Add([]byte{127, 255, 0, 128}, []byte{4})

	hash1 := tree.Hash()

	tree.Add([]byte{127, 255, 0, 1}, []byte{5})
	hash2 := tree.Hash()

	if bytes.Equal(hash1, hash2) {
		t.Error("Change value, but hash still the same")
	}

	tree.Add([]byte{127, 255, 0, 1}, []byte{3})
	hash3 := tree.Hash()

	if !bytes.Equal(hash1, hash3) {
		t.Error("Restore value, but hash doesn't equal the old one")
	}

}

func ExampleMerkleTrie_MaxDepth() {
	tree := trie.NewMerkleTrie()
	fmt.Println(tree.MaxDepth())

	tree.Add([]byte{0, 0, 0, 0}, []byte{0})
	tree.Add([]byte{255, 255, 0, 128}, []byte{1})
	fmt.Println(tree.MaxDepth())

	tree.Add([]byte{0, 255, 0, 1}, []byte{2})
	fmt.Println(tree.MaxDepth())

	tree.Add([]byte{127, 255, 0, 1}, []byte{3})
	tree.Add([]byte{127, 255, 0, 128}, []byte{4})
	fmt.Println(tree.MaxDepth())

	// Output:
	// 0
	// 1
	// 9
	// 25
}

func TestIgnoreOrder(t *testing.T) {
	tree1 := trie.NewMerkleTrie()
	tree1.Add(zero(), []byte{0})
	tree1.Add(one(), []byte{1})
	hash1 := tree1.Hash()

	tree2 := trie.NewMerkleTrie()
	tree2.Add(one(), []byte{1})
	tree2.Add(zero(), []byte{0})
	hash2 := tree2.Hash()

	if !bytes.Equal(hash1, hash2) {
		t.Error("Different hashes for different orders")
	}
}

func Benchmark(b *testing.B) {
	tree := trie.NewMerkleTrie()

	for i := 0; i < b.N; i++ {
		key := make([]byte, 32)
		rand.Read(key)
		tree.Add(key, key)
	}
}

func zero() []byte {
	return make([]byte, 32, 32)
}

func one() []byte {
	one := make([]byte, 32, 32)
	one[31] = 1
	return one
}

func highBit() []byte {
	res := make([]byte, 32, 32)
	res[0] = 128
	return res
}

func max() []byte {
	res := make([]byte, 32, 32)
	for i := range res {
		res[i] = 255
	}
	return res
}
